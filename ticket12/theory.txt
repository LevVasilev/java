1.Сборщик мусора:
Сборка мусора — это процесс автоматического управления памятью в куче, который заключается в поиске неиспользующихся участков памяти, которые ранее были заняты под нужды программы. Это один из наиболее популярных вариантов механизма для управления памятью в современных языках программирования. Подпрограмма сборки мусора обычно запускается в заранее определённые интервалы времени и бывает, что её запуск совпадает с ресурсозатратными процессами, в результате чего происходит задержка в работе приложения. Используется в JVM (Java/Scala/Groovy/Kotlin).
Сборщик мусора на основе алгоритма пометок (Mark & Sweep):
Это алгоритм, работа которого происходит в две фазы: первым делом он помечает объекты в памяти, на которые имеются ссылки, а затем освобождает память от объектов, которые пометки не получили. Этот подход используется, например, в JVM, C#, Ruby, JavaScript и Golang. В JVM существует на выбор несколько разных алгоритмов сборки мусора, а JavaScript-движки, такие как V8, используют алгоритм пометок в дополнение к подсчёту ссылок. Такой сборщик мусора можно подключить в C и C++ в виде внешней библиотеки.
RAII:
RAII — это программная идиома в ООП, смысл которой заключается в том, что выделяемая для объекта область памяти строго привязывается к его времени существования. Память выделяется в конструкторе и освобождается в деструкторе. Данный подход был впервые реализован в C++, а так же используется в Ada и Rust.

В Java есть Стек (с областью видимости данных), куча. Java по возможности сохраняет и повторно использует строки (String).
При удалении данных Java ипользует процесс «Mark and Sweep». Java анализирует переменные из кучи и «отмечает» все объекты, которые необходимо поддерживать в рабочем состоянии (при отсутствии каких либо ссылок на объект программа заключает, что этот объект больше не нужен, и занимаемую объектом память можно освободить). Затем все неиспользуемые объекты очищаются.

Если объект взаимодействует с какими-то ресурсами, например открывает поток вывода и читает из него, то такой поток необходимо закрыть перед удалением объекта из памяти. Для этого в языке Java достаточно переопределить метод finalize(), который вызывается в исполняющей среде Java непосредственно перед удалением объекта данного класса. В теле метода finalize() нужно указать те действия, которые должны быть выполнены перед уничтожением объекта. Метод finalize() вызывается лишь непосредственно перед сборкой "мусора".
Метод finalize() не вызывается при выходе объекта из области действия. Заранее неизвестно, когда будет (и будет ли вообще) выполняться метод finalize(). И самое главное - начиная с Java 9 этот метод не рекомендуется к использованию.
public class Spoon {
    @Override
    protected void finalize() {
        System.out.println("Ложка исчезает навсегда");
    }
}
2.Для создания простых списков применяется интерфейс List, который расширяет функцональность интерфейса Collection. 
Класс ArrayList представляет обобщенную коллекцию, которая наследует свою функциональность от класса AbstractList и применяет интерфейс List. Проще говоря, ArrayList представляет простой список, аналогичный массиву, за тем исключением, что количество элементов в нем не фиксировано.
