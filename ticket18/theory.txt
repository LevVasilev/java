1.
Циклические конструкции в Java. Использование циклов для работы с массивами. Использование итераторов для обработки массивов.
Еще одним видом управляющих конструкций являются циклы. Циклы позволяют в зависимости от определенных условий выполнять определенное действие множество раз. 
В Джава есть три классических вида цикла и один улучшенный:
Итерационный for()
С предусловием while()
С постусловием do{} while()
for : each для работы с массивами и коллекциями

1)Итерационный for() имеет следующее формальное определение:
for ([инициализация счетчика]; [условие]; [изменение счетчика]){
 	// действия
} 
например фрагмент кода ниже:
for(int x = 10; x < 15; x = x+1) {
    System.out.print("Значение x: " + x );
    System.out.print("\n");
}
Возможные виды изменения счетчика: i++, i--, ++i, --i, i+/- const (где i – переменная-счетчик)

2)С предусловием while(), например фрагмент кода ниже:
int x = 10;
while( x < 15 ) {
    System.out.print("Значение x: " + x);
    x++;
    System.out.print("\n");
}

3)С постусловием do{} while(), например фрагмент кода ниже:
int x = 10;
do{
    System.out.print("Значение х: " + x );
    x++;
    System.out.print("\n");
} while( x < 15 );

4)Отдельно стоит оператор for : each для работы с массивами и коллекциями, например фрагмент кода ниже:
int [] numbers = {-1, 0, 5, 6, 10};
for(int x : numbers ){
    System.out.print(x);
    System.out.print("\n");
}
Использование циклов для работы с массивами
Перебор массива
int[] aNums = { 2, 4, 6 };
for (int i = 0; i < aNums.length; i++) {
    System.out.println(aNums[i]);
}
или 
for (int i: aNums) {
    System.out.println(i);
}

Одним из ключевых методов интерфейса Collection является метод Iterator<E> iterator(). Он возвращает итератор - то есть объект, реализующий интерфейс Iterator.

Интерфейс Iterator имеет следующее определение:

public interface Iterator <E>{ 
    E next();
    boolean hasNext();
    void remove();
}
Реализация интерфейса предполагает, что с помощью вызова метода next() можно получить следующий элемент. С помощью метода hasNext() можно узнать, есть ли следующий элемент, и не достигнут ли конец коллекции. И если элементы еще имеются, то hasNext() вернет значение true. Метод hasNext() следует вызывать перед методом next(), так как при достижении конца коллекции метод next() выбрасывает исключение NoSuchElementException. И метод remove() удаляет текущий элемент, который был получен последним вызовом next().

Используем итератор для перебора коллекции ArrayList:

import java.util.*;
 
public class Program {
 
    public static void main(String[] args) {
         
        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(1, 3245, 3, 5, 7, 23));
        Iterator<String> iter = arr.iterator();
        while(iter.hasNext()){
            System.out.println(iter.next());
        }
    }
}

Интерфейс ListIterator расширяет интерфейс Iterator и определяет ряд дополнительных методов:

void add(E obj): вставляет объект obj перед элементом, который должен быть возвращен следующим вызовом next()

boolean hasNext(): возвращает true, если в коллекции имеется следующий элемент, иначе возвращает false

boolean hasPrevious(): возвращает true, если в коллекции имеется предыдущий элемент, иначе возвращает false

E next(): возвращает текущий элемент и переходит к следующему, если такого нет, то генерируется исключение NoSuchElementException

E previous(): возвращает текущий элемент и переходит к предыдущему, если такого нет, то генерируется исключение NoSuchElementException

int nextIndex(): возвращает индекс следующего элемента. Если такого нет, то возвращается размер списка

int previousIndex(): возвращает индекс предыдущего элемента. Если такого нет, то возвращается число -1

void remove(): удаляет текущий элемент из списка. Таким образом, этот метод должен быть вызван после методов next() или previous(), иначе будет сгенерировано исключение IlligalStateException

void set(E obj): присваивает текущему элементу, выбранному вызовом методов next() или previous(), ссылку на объект obj

Используем ListIterator:

import java.util.*;
 
public class Program {
 
    public static void main(String[] args) {
         
        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(1, 3245, 3, 5, 7, 23));
        ListIterator<String> listIter = arr.listIterator();
         
        while(listIter.hasNext()){
         
            System.out.println(listIter.next());
        }
        // сейчас текущий элемент - 23
        // изменим значение этого элемента
        listIter.set(66);
        // пройдемся по элементам в обратном порядке
        while(listIter.hasPrevious()){
         
            System.out.println(listIter.previous());
        }  

    }
}

2.
Возможности Java Framework Collection
Java Collection Framework — иерархия интерфейсов и их реализаций, которая является частью JDK и позволяет разработчику пользоваться большим количеством структур данных из «коробки».
Интерфейс Map и его основные методы
Интерфейс Map представляет отображение или иначе говоря словарь, где каждый элемент представляет пару "ключ-значение". При этом все ключи уникальные в рамках объекта Map. Такие коллекции облегчают поиск элемента, если нам известен ключ - уникальный идентификатор объекта. В отличие от других интерфейсов коллекций не наследуется от интерфейса Collection (!!!).
