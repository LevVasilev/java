1.	При работе со строками, а именно конкатенацией, не желательно использовать оператор «+». Для этих целей следует использовать StringBuffer или StringBuilder.
С помощью “+”:

Конкатенация строк с помощью StringBuffer и StringBuilder будут аналогичны друг другу: 

Объекты String являются неизменяемыми, поэтому все операции, которые изменяют строки, фактически приводят к созданию новой строки, что сказывается на производительности приложения. Для решения этой проблемы, чтобы работа со строками проходила с меньшими издержками в Java были добавлены классы StringBuffer и StringBuilder. По сути они напоминает расширяемую строку, которую можно изменять без ущерба для производительности.

Эти классы похожи, практически двойники, они имеют одинаковые конструкторы, одни и те же методы, которые одинаково используются. Единственное их различие состоит в том, что класс StringBuffer синхронизированный и потокобезопасный. То есть класс StringBuffer удобнее использовать в многопоточных приложениях, где объект данного класса может меняться в различных потоках. Если же речь о многопоточных приложениях не идет, то лучше использовать класс StringBuilder, который не потокобезопасный, но при этом работает быстрее, чем StringBuffer в однопоточных приложениях.
Список методов, поддерживаемых классом StringBuffer:

№	Описание
1	public StringBuffer append(String s)
Обновляет значение объекта, который вызывает метод. Этот метод принимает boolean, char, int, long, Strings и т.д.
2	public StringBuffer reverse()
Этот метод изменяет значение объекта StringBuffer, который вызывает метод.
3	public delete(int start, int end)
Удаляет строку, начиная с начального индекса до конечного индекса.
4	public insert(int offset, int i)
Этот метод вставляет строку s в позицию упомянутую по смещению.
5	replace(int start, int end, String str)
Этот метод заменяет символы в подстроке данного StringBuffer символами в указанной строке.

2. Паттерны проектирования (шаблоны проектирования) - это готовые к использованию решения часто возникающих в программировании задач. Это не класс и не библиотека, которую можно подключить к проекту, это нечто большее. Паттерны проектирования, а подходящий под задачу, реализуется в каждом конкретном случае.
Фабричный метод — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.
Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого фабричного метода. Не пугайтесь, объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод (он содержит в себе switch из значений перечисления. По передаваемому в него значению перечисления определяется, конструктор какого класса будет вызван)


Типы паттернов:

порождающие
структурные
поведенческие
Порождающие паттерны предоставляют механизмы инициализации, позволяя создавать объекты удобным способом.

Структурные паттерны определяют отношения между классами и объектами, позволяя им работать совместно.

Поведенческие паттерны используются для того, чтобы упростить взаимодействие между сущностями.
(далее идут примеры, которые вряд ли будут спрашивать)

Порождающие:

Singleton (Одиночка) - ограничивает создание одного экземпляра класса, обеспечивает доступ к его единственному объекту.
Factory (Фабрика) - используется, когда у нас есть суперкласс с несколькими подклассами и на основе ввода, нам нужно вернуть один из подкласса.
Abstract Factory (Абстрактная фабрика) - используем супер фабрику для создания фабрики, затем используем созданную фабрику для создания объектов.
Builder (Строитель) - используется для создания сложного объекта с использованием простых объектов. Постепенно он создает больший объект от малого и простого объекта.
Prototype (Прототип) - помогает создать дублированный объект с лучшей производительностью, вместо нового создается возвращаемый клон существующего объекта.
Структурные:

Adapter (Адаптер) - это конвертер между двумя несовместимыми объектами. Используя паттерн адаптера, мы можем объединить два несовместимых интерфейса.
Composite (Компоновщик) - использует один класс для представления древовидной структуры.
Proxy (Заместитель) - представляет функциональность другого класса.
Flyweight (Легковес) - вместо создания большого количества похожих объектов, объекты используются повторно.
Facade (Фасад) - беспечивает простой интерфейс для клиента, и клиент использует интерфейс для взаимодействия с системой.
Bridge (Мост) - делает конкретные классы независимыми от классов реализации интерфейса.
Decorator (Декоратор) - добавляет новые функциональные возможности существующего объекта без привязки его структуры.
Поведенческие:

Template Method (Шаблонный метод) - определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
Mediator (Посредник) - предоставляет класс посредника, который обрабатывает все коммуникации между различными классами.
Chain of Responsibility (Цепочка обязанностей) - позволяет избежать жесткой зависимости отправителя запроса от его получателя, при этом запрос может быть обработан несколькими объектами.
Observer (Наблюдатель) - позволяет одним обьектам следить и реагировать на события, происходящие в других объектах.
Strategy (Стратегия) - алгоритм стратегии может быть изменен во время выполнения программы.
Command (Команда) - интерфейс команды объявляет метод для выполнения определенного действия.
State (Состояние) - объект может изменять свое поведение в зависимости от его состояния.
Visitor (Посетитель) - используется для упрощения операций над группировками связанных объектов.
Interpreter (Интерпретатор) - определяет грамматику простого языка для проблемной области.
Iterator (Итератор) - последовательно осуществляет доступ к элементам объекта коллекции, не зная его основного представления.
Memento (Хранитель) - используется для хранения состояния объекта, позже это состояние можно восстановить.
